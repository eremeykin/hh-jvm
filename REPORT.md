## Профилирование JVM приложения

### Праметры системы

| Название      | Значение                                 |
| ------------- |------------------------------------------|
| ПК            | Lenovo ThinkPad T570                     |
| Процессор     | Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz |
| ОЗУ           | 8192 MB DDR4 @ 2133 MHz                  |
| OC            | 16.04.1-Ubuntu x86_64                    |
| Java          | Java(TM) SE Runtime Environment (build 1.8.0_144-b01)|
| JVM           | Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)|
| JMC           | 5.5.1                                    |
| jmap          | из JDK 1.8.0_144                                        |
|maven        | 3.3.9                                       |

### Репозиторий.
В репозитории [hh-jvm](https://github.com/eremeykin/hh-jvm/) есть три ветки:
* `master` - ветка исходного репозитория [money-transfer](https://github.com/yarkinsv/money-transfer)
* `automation` - ветка автоматизации профилирования, тут созданы файлы `profile.sh` скрипт автоматизирующий профилирование и `flight-recorder.jfc` файл с настройками для FlightRecorder
* `develop` - ветка с изменениями в java коде для улучшения производительности.
Стадии экспетиментов помечены тегами `stage_<#стадии>`

### Стадии экспериментов
Эксперименты проводятся в несколько стадий, каждая стадия отличается от предыдущей изменениями в коде и на каждой стадии снимаются показатели производительности текущей версии кода. Всего есть 4 стадии :
* Стадия 0 (тег `stage_0`): код без изменений
На этой стадии выделяются основные ошибки, которые удается найти исключительно с помощью профилировщика, без инспекции кода.
* Стадия 1 (тег `stage_1`): код содержит исправления, найденные на предыдущей стадии, но более детальная инспекция кода не проводится.
* Стадия 2 (тег `stage_2`): проведен анализ кода, найденные недостатки устранены
* Стадия 3 (тег `stage_3`): реализация DAO переписана, хранение реализовано в структкрах данных Java.
* Стадия 4 (тег `stage_4`): анализ различных GC

### Замеряемые величины.
<Дополнить раздел>

### Инструменты
Для замеров используются следующие инструменты:
* самописный bash скрипт `profile.sh` для автоматизации замеров и обеспечения хотябы небольшой степени воспроизводимости экспериментов.
* самописный python скрипт `analyze.py` для построения графика времени выполнения сценария 1.
* [FlightRecorder](https://docs.oracle.com/javacomponents/jmc-5-5/jfr-runtime-guide/about.htm) для записи `jfr` файлов с различными измеряемыми параметрами, перечисленными в файле `flight-recorder.jfc`
* [Java Mission Control](https://www.oracle.com/technetwork/java/javaseproducts/mission-control/index.html) для анализа `jfr` файлов. Файлы `jfr` объемные и в репозиторий не входят.
* [jmap](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html) для сохранения бинарный дампов памяти. Дампы большие, в репозиторий не входят.
* [jvisualvm](https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/index.html) для анализа дампов памяти и фильтарции объектов по пакету

### Методика
В `run_test.py` добавлен вывод прошедшего с момента запуска времени, этот вывод мы будем перенаправлять в файл `.plg` (python log) и потом анализировать.
На каждой стадии запускаем самописный скрипт командой
`./profile.sh --clear && ./profile.sh --dump && sleep 30 && ./profile.sh`
* `./profile.sh --clear` чистит старые дампы и `jfr` файлы и делает `mvn clean install`
* `./profile.sh --dump` запускает jar-ник и раз в 2 мин делает дамп через `jmap` в течении 10 мин
* `./profile.sh` - записывает jfr файл в течении 10 мин с помощью FlightRecorder и JMC .
*Таким образом, сохранение дампов и запись jfr файлов происходит на разных запусках jar-ника.*

После выполнения скрипта получаем файлы:
* два jfr - один тот, в процессе записи которого не создавались дампы, а второй записывался одновременно с созданием дампов. Для анализа интересен первый
* два plg файла, это файлы output потока python скрипта `run_test.py`, в который мы еще добавили время для каждой итерации. Их также два так как один во вермя "чистого" прогона, а второй во время сохранения дампов памяти. Инетересен первый. 
* дампы памяти, их как парвило 5, так как 10 минут пишем через каждые 2 мин.
Полученные файлы анализируются с помощью jvisualvm (для дампов) и JMC (для .jfr), а также самописным python скриптом `analyze.py`(для построения графика времени выполнения сценария 1 по .plg файлу)

### Этап 0. 
Анилиз производительности приложения до изменений кода.
* Выясняется, что сохранение дампов во время работы практически не сказывается на производительности, поэтому на самом деле можно запускать один раз на 10 мин `./profile.sh --dump`, вместо того чтобы за первый проход собирать дампы, а за второй писать события FlightRecorder'ом.

* *На сколько загружен CPU?*
В среднем около 25%:
![image](https://user-images.githubusercontent.com/7558836/50046075-5280e800-00ae-11e9-914f-82a2fb50d00f.png)


* *Сколько в среднем потребляется памяти, заметен ли в программе memory leak?*
От 55 Мб до 130Мб:
![image](https://user-images.githubusercontent.com/7558836/50046088-82c88680-00ae-11e9-98b4-304054411a2f.png)
Дамп №3 
![image](https://user-images.githubusercontent.com/7558836/50046133-3893d500-00af-11e9-9f37-850fd08592b5.png)
Заметим, что создано несколько объектов типа `*DAOImpl` и довольно  много объектов `Account` и `User`.

* *Как часто происходит сборка мусора?*
За время эксперимента (10мин 11с) произошла 717 раз. Средняя пауза 2 ms 111 μs, максимальная 99 ms 146 μs

* *Cколько в среднем выполняется запуск сценария 1, как быстро увеличивается это время?*
На графике показано среднее время `Execution time average` и текщее время `Execution time last` в секундах зависимости от числа выполнения сценария 1 `Function play_scenario_1 called`. 
![image](https://user-images.githubusercontent.com/7558836/50046204-a260ae80-00b0-11e9-9f6b-f76c0da82da0.png)


* *Какие операции из значимых (т.е. без учета работы системных функций, в т.ч. веб сервера) занимают больше всего процессорного времени?*
![image](https://user-images.githubusercontent.com/7558836/50046234-3df21f00-00b1-11e9-9f2a-25e89fe12636.png)

* **ВЫВОДЫ СТАДИИ 0**
1) Проверить как создаются и куда сохраняются объекты `Account` и `User`.
2) Проверить почему создается много объектов типа `*DAOImpl`
3) Проверить вызов методов `AccountDAOImpl.getAllAccounts()`, `UserDAOImpl.getAllUsers()`

### Стадия 1. 
При поверхностном анализе найдено, что
1) Можно переиспользовать `DAOImpl` так как это объекты без состояния
2) Есть утечка памяти, когда в объекте `UserDAOImpl` сохраняются неиспользуемые объекты `User`
Проверяем как исправления повлияют на результат. 

* *На сколько загружен CPU?*
Загрузка примерно такая же
![image](https://user-images.githubusercontent.com/7558836/50046260-e86a4200-00b1-11e9-98e7-b53b15058848.png)


* *Сколько в среднем потребляется памяти, заметен ли в программе memory leak?*
![image](https://user-images.githubusercontent.com/7558836/50046263-06d03d80-00b2-11e9-8461-0b59ace423fd.png)
Дамп №3 
![image](https://user-images.githubusercontent.com/7558836/50046271-2cf5dd80-00b2-11e9-942a-750e94edf323.png)


Хотя бы тут есть какая-то польза! Сразу **заметно сократилось число обоъектов**, как `DAOImpl`,  так и моделей `Account` и `User`. Возможно время сбора дампа пришлось после сборки мусора? 

Да, тут моделей больше, но от `DAOImpl` мы избавились.

* *Как часто происходит сборка мусора?*
За время эксперимента произошла 856 раз,  Средняя пауза 1 ms 971 μs, максимальная 103 ms 866 μs

* *Cколько в среднем выполняется запуск сценария 1, как быстро увеличивается это время?*
На графике времени выполнения сценария 1 практически ничего не изменилось:
![image](https://user-images.githubusercontent.com/7558836/50046307-9a097300-00b2-11e9-96f1-80db523428ef.png)


* *Какие операции из значимых (т.е. без учета работы системных функций, в т.ч. веб сервера) занимают больше всего процессорного времени?*
![image](https://user-images.githubusercontent.com/7558836/50046326-c8874e00-00b2-11e9-96f3-721cc196e797.png)

* **ВЫВОДЫ СТАДИИ 1**
1) Сокращено количество объектов `*DAOImpl` `Account` и `User` в heap'е, что на общую картину потребления памяти практически не повлияло
2) Загрузка ЦП не уменьшилась, статастика по методам существенно не изменилась
3) Надо искать утечки более внимательно

### Стадия 2. 

На этой стадии были выявлены и устранены следующие дефекты:

1) Исправлен метод `getAccountByUser()`, в котором был странно написан `return`
2) Улучшен метод `hashCode()`, который всегда возвращал 1
3) В методах getDAO убрано `loadDriver`
4) Найден еще один memory leak, добавлено переиспользование `Pattern`
5) Переупорядочено сравнение в `equals()`

Посмотрим, как это скажется на производительности.


* *На сколько загружен CPU?*
В среднем на 12-14%
![image](https://user-images.githubusercontent.com/7558836/50046359-1ef48c80-00b3-11e9-91f3-c966a7b2eb45.png)

* *Сколько в среднем потребляется памяти, заметен ли в программе memory leak?*
![image](https://user-images.githubusercontent.com/7558836/50046364-32075c80-00b3-11e9-8f6a-0e9d698a3575.png)
Дамп №3:
![image](https://user-images.githubusercontent.com/7558836/50046372-4cd9d100-00b3-11e9-9499-a82882836ba2.png)

* *Как часто происходит сборка мусора?*
За время эксперимента произошла 1359 раз, средняя пауза 2 ms 458 μs, максимальная 113 ms 650 μs

* *Cколько в среднем выполняется запуск сценария 1, как быстро увеличивается это время?*
![image](https://user-images.githubusercontent.com/7558836/50046390-a2ae7900-00b3-11e9-8338-f2daef259dcf.png)

* *Какие операции из значимых (т.е. без учета работы системных функций, в т.ч. веб сервера) занимают больше всего процессорного времени?*
![image](https://user-images.githubusercontent.com/7558836/50046418-de494300-00b3-11e9-9659-16835e196044.png)
